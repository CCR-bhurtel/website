---
sidebar_position: 1
sidebar_label: Defining a Model
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import DecoratorInfo from '../_fragments/_decorator-info.mdx';

# Model Basics

In this tutorial you will learn what models are in Sequelize and how to use them.

## Concept

Models are the essence of Sequelize. A model is an abstraction that represents a table in your database.
In Sequelize, it is a class that extends [the `Model` class](pathname:///api/v7/classes/Model.html).

The model tells Sequelize several things about the entity it represents, such as the name of the table in the database and which columns it has (and their data types).

A model in Sequelize has a name. This name does not have to be the same name of the table it represents in the database. Usually, models have singular names (such as `User`)
while tables have pluralized names (such as `users`), although this is fully configurable.

Each instance of a model maps to one row of the table in the database. Basically, model instances are [DAOs](https://en.wikipedia.org/wiki/Data_access_object).

## Defining a Model

This chapter will go into detail about how to create a model in Sequelize.
Sequelize uses a class-based approach to define models, and makes heavy uses of decorators to define the model's metadata.
You can choose to [avoid using decorators](#without-decorators), but you should read this chapter first.

<DecoratorInfo />

To learn with an example, we will consider that we want to create a model to represent users, which have a `firstName` and a `lastName`. 
We want our model to be called `User`, and the table it represents is called `users` in the database.

Defining a model is simple: Create a class that extends [the `Model` class](pathname:///api/v7/classes/Model.html),
and add instance properties to it.

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts
import { Sequelize, DataTypes, Model, InferAttributes, InferCreationAttributes, CreationOptional } from '@sequelize/core';

const sequelize = new Sequelize('sqlite::memory:');

export class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
  @Attibute(DataTypes.INTEGER)
  @PrimaryKey
  @AutoIncrement
  declare id: CreationOptional<number>;

  @Attribute(DataTypes.STRING)
  @NotNull
  declare firstName: string;
 
  @Attribute(DataTypes.STRING)
  declare lastName: string | null;
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
import { Sequelize, DataTypes, Model } from '@sequelize/core';

const sequelize = new Sequelize('sqlite::memory:');

export class User extends Model {
  @Attibute(DataTypes.INTEGER)
  @PrimaryKey
  @AutoIncrement
  id;

  @Attribute(DataTypes.STRING)
  @NotNull
  firstName;
 
  @Attribute(DataTypes.STRING)
  lastName;
}
```

</TabItem>  
</Tabs>

### Without Decorators

:::note

This subsection will only present how to define a model without using decorators.
You should read [the previous section](#defining-a-model) first to get an overview of how to define a model.

:::

### Legacy Definition methods

If you're working on a project that was created before Sequelize 7, you're likely using the old way of defining models.
This is still supported, but we recommend to use the [new way of defining models](#defining-a-model).

Head to [our page about Legacy Model Definitions](../other-topics/legacy-model-definitions.mdx) to learn more about the old API.

## Caveat with Public Class Fields

Adding a [Public Class Field](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields) with the same name as one of the model's attribute is going to cause issues.
Sequelize adds a getter & a setter for each attribute defined through `Model.init`.
Adding a Public Class Field will shadow those getter and setters, blocking access to the model's actual data.

This is an issue we're working on. [Head to this issue for more information](https://github.com/sequelize/meetings/issues/16).

```typescript
// Invalid
class User extends Model {
  id; // this field will shadow sequelize's getter & setter. It should be removed.
  otherPublicField; // this field does not shadow anything. It is fine.
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // undefined
```

```typescript
// Valid
class User extends Model {
  otherPublicField;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1
```

In TypeScript, you can add typing information without adding an actual public class field by using the `declare` keyword:

```typescript
// Valid
class User extends Model {
  declare id: number; // this is ok! The 'declare' keyword ensures this field will not be emitted by TypeScript.
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1
```

## Caveat with minification

:::caution Model Names & Minification

When defining a model using the class-based approach, the name of the model will, by default, be the name of your class.
In the above example, the name of the model is `User`.

If you minify your code, it is possible that the class' name — and therefore its model name — will be changed by your minifier.
This can be an issue, as many systems use your modelName, from [Sequelize#models](pathname:///api/v7/classes/Sequelize.html#models)
to [the name of your Database table name](./naming-strategies.mdx).

The solution to prevent this issue is to explicitly set the `modelName` option:

```typescript
class User extends Model {}

User.init({ /* attributes */ }, {
  /* other model options */

  // by specifying 'modelName' explicitely, the name of this model can be safely minified.
  modelName: 'User',
});
```

:::


## Column declaration shorthand syntax

If the only thing being specified about a column is its data type, the syntax can be shortened:

```js
// This:
sequelize.define('User', {
  // name is a nullable string
  name: DataTypes.STRING,
});

// Is equivalent to this:
sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
  },
});
```

## Default Values

By default, Sequelize assumes that the default value of a column is `NULL`. This behavior can be changed by passing a specific `defaultValue` to the column definition:

```js
sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
    defaultValue: "John Doe"
  }
});
```

Some special values, such as [`DataTypes.NOW`](./data-types.mdx#built-in-default-values-for-dates) and [`DataTypes.UUIDV4`](./data-types.mdx#built-in-default-values-for-uuid), are also accepted:

```js
sequelize.define('Foo', {
  bar: {
    type: DataTypes.DATETIME,
    defaultValue: DataTypes.NOW
    // This way, the current date/time will be used to populate this column (at the moment of insertion)
  }
});
```

## Column Data Types

Every attribute you define in your model must have a data type.
e.g. an attribute with a type `DataTypes.INTEGER` will result in a column of type `integer`.

[The list of supported Data Types is available here](./data-types.mdx).

## Column Options

When defining a column, apart from specifying the `type` of the column, and the `allowNull` and `defaultValue` options mentioned above, there are a lot more options that can be used. Some examples are below.

```js
import { Model, DataTypes, Deferrable } from '@sequelize/core';

class Foo extends Model {}
Foo.init({
  // instantiating will automatically set the flag to true if not set
  flag: { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: true },

  // default values for dates => current time
  myDate: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },

  // setting allowNull to false will add NOT NULL to the column, which means an error will be
  // thrown from the DB when the query is executed if the column is null. If you want to check that a value
  // is not null before querying the DB, look at the validations section below.
  title: { type: DataTypes.STRING, allowNull: false },

  // Creating two objects with the same value will throw an error. The unique property can be either a
  // boolean, or a string. If you provide the same string for multiple columns, they will form a
  // composite unique key.
  uniqueOne: { type: DataTypes.STRING,  unique: 'compositeIndex' },
  uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' },

  // The unique property is simply a shorthand to create a unique constraint.
  someUnique: { type: DataTypes.STRING, unique: true },

  // Go on reading for further information about primary keys
  identifier: { type: DataTypes.STRING, primaryKey: true },

  // autoIncrement can be used to create auto_incrementing integer columns
  incrementMe: { type: DataTypes.INTEGER, autoIncrement: true },

  // You can specify a custom column name via the 'field' attribute:
  fieldWithUnderscores: { type: DataTypes.STRING, field: 'field_with_underscores' },

  // It is possible to create foreign keys:
  bar_id: {
    type: DataTypes.INTEGER,

    references: {
      // This is a reference to another model
      model: Bar,

      // This is the column name of the referenced model
      key: 'id',

      // With PostgreSQL, it is optionally possible to declare when to check the foreign key constraint, passing the Deferrable type.
      deferrable: Deferrable.INITIALLY_IMMEDIATE
      // Options:
      // - `Deferrable.INITIALLY_IMMEDIATE` - Immediately check the foreign key constraints
      // - `Deferrable.INITIALLY_DEFERRED` - Defer all foreign key constraint check to the end of a transaction
      // - `Deferrable.NOT` - Don't defer the checks at all (default) - This won't allow you to dynamically change the rule in a transaction
    }
  },

  // Comments can only be added to columns in MySQL, MariaDB, PostgreSQL and MSSQL
  commentMe: {
    type: DataTypes.INTEGER,
    comment: 'This is a column name that has a comment'
  }
}, {
  sequelize,

  // Using `unique: true` in an attribute above is exactly the same as creating the index in the model's options:
  indexes: [{ unique: true, fields: ['someUnique'] }]
});
```

## Model Methods

Sequelize models are [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
You can very easily add custom instance or class level methods.

:::info

`Model` provides a suite of built-in static & instance methods that can be used to interact with the database.

[Take a look at the API Reference for `Model`](pathname:///api/v7/classes/Model.html) for more information

:::

<Tabs>
<TabItem value="ts" label="TypeScript">

```typescript
import { InferCreationAttributes, InferAttributes, Model } from '@sequelize/core';

class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
  declare firstname: string | null;
  declare lastname: string | null;

  instanceLevelMethod() {
    return 'bar';
  }

  getFullname() {
    return [this.firstname, this.lastname].join(' ');
  }

  static classLevelMethod() {
    return 'foo';
  }
}

User.init({
  firstname: Sequelize.TEXT,
  lastname: Sequelize.TEXT
}, { sequelize });

console.log(User.classLevelMethod()); // 'foo'
const user = User.build({ firstname: 'Jane', lastname: 'Doe' });
console.log(user.instanceLevelMethod()); // 'bar'
console.log(user.getFullname()); // 'Jane Doe'
```

</TabItem>
<TabItem value="js" label="JavaScript">

```typescript
import { Model } from '@sequelize/core';

class User extends Model {
  instanceLevelMethod() {
    return 'bar';
  }

  getFullname() {
    return [this.firstname, this.lastname].join(' ');
  }

  static classLevelMethod() {
    return 'foo';
  }
}

User.init({
  firstname: Sequelize.TEXT,
  lastname: Sequelize.TEXT
}, { sequelize });

console.log(User.classLevelMethod()); // 'foo'
const user = User.build({ firstname: 'Jane', lastname: 'Doe' });
console.log(user.instanceLevelMethod()); // 'bar'
console.log(user.getFullname()); // 'Jane Doe'
```

</TabItem>
</Tabs>
