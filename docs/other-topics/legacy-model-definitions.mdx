---
title: Optimistic Locking
---

import CodeBlock from '@theme/CodeBlock';

# Legacy Model Definitions

:::caution

This API is considered legacy. It is still supported, but we strongly recommend to use the [new way of defining models](#defining-a-model), 
as this legacy API can easily make your models complex if you need to declare an association.

:::

There are two legacy ways of defining models:

* Extending [Model](pathname:///api/v7/classes/Model.html), and calling its [`init(attributes, options)`](pathname:///api/v7/classes/Model.html#init) static method
* Calling [`sequelize.define(modelName, attributes, options)`](pathname:///api/v7/classes/Sequelize.html#define)

## Extending [Model](pathname:///api/v7/classes/Model.html)

<Tabs>
<TabItem value="ts" label="TypeScript">

Learn more about using Sequelize with TypeScript in [our TypeScript guide](../other-topics/typescript.mdx).

```typescript
import { Sequelize, DataTypes, Model, InferAttributes, InferCreationAttributes, CreationOptional } from '@sequelize/core';

const sequelize = new Sequelize('sqlite::memory:');

class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
  declare id: CreationOptional<number>;
  declare firstName: string;
  declare lastName: string | null;
}

User.init({
  // Model attributes are defined here
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true,
  },
  firstName: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  lastName: {
    type: DataTypes.STRING,
    // allowNull defaults to true, except for primary keys
  },
}, {
  // Other model options go here
  sequelize, // We need to pass the connection instance
});

// Once init has been called, the model also becomes available through sequelize.models
console.log(User === sequelize.models.User); // true
```

</TabItem>
<TabItem value="js" label="JavaScript (CJS)">

```javascript
import { Sequelize, DataTypes, Model } from '@sequelize/core';
const sequelize = new Sequelize('sqlite::memory:');

class User extends Model {}

User.init({
  // Model attributes are defined here
  firstName: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  lastName: {
    type: DataTypes.STRING,
    // allowNull defaults to true, except for primary keys
  },
}, {
  // Other model options go here
  sequelize, // We need to pass the connection instance
});

// Once init has been called, the model also becomes available through sequelize.models
console.log(User === sequelize.models.User); // true
```

</TabItem>
</Tabs>

## Using [`sequelize.define`](pathname:///api/v7/classes/Sequelize.html#define)

Internally, `sequelize.define` calls `Model.init`, so both approaches are essentially equivalent.

```js
import { Sequelize, DataTypes } from '@sequelize/core';
const sequelize = new Sequelize('sqlite::memory:');

const User = sequelize.define('User', {
  // Model attributes are defined here
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
    // allowNull defaults to true, except for primary keys
  }
}, {
  // Other model options go here
});

// The model is also available through sequelize.models
console.log(User === sequelize.models.User); // true
```

## With TypeScript

### The case of `Model.init`

`Model.init` requires an attribute configuration for each attribute declared in typings.

Some attributes don't actually need to be passed to `Model.init`, this is how you can make this static method aware of them:

- Methods used to define associations (`Model.belongsTo`, `Model.hasMany`, etcâ€¦) already handle
  the configuration of the necessary foreign keys attributes. It is not necessary to configure
  these foreign keys using `Model.init`.
  Use the `ForeignKey<>` branded type to make `Model.init` aware of the fact that it isn't necessary to configure the foreign key:

  ```typescript
  import { Model, InferAttributes, InferCreationAttributes, DataTypes, ForeignKey } from '@sequelize/core';

  class Project extends Model<InferAttributes<Project>, InferCreationAttributes<Project>> {
    id: number;
    userId: ForeignKey<number>;
  }

  // this configures the `userId` attribute.
  Project.belongsTo(User);

  // therefore, `userId` doesn't need to be specified here.
  Project.init({
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
  }, { sequelize });
  ```

- Timestamp attributes managed by Sequelize (by default, `createdAt`, `updatedAt`, and `deletedAt`) don't need to be configured using `Model.init`,
  unfortunately `Model.init` has no way of knowing this. We recommend you use the minimum necessary configuration to silence this error:

  ```typescript
  import { Model, InferAttributes, InferCreationAttributes, DataTypes } from '@sequelize/core';

  class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
    id: number;
    createdAt: Date;
    updatedAt: Date;
  }

  User.init({
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    // technically, `createdAt` & `updatedAt` are added by Sequelize and don't need to be configured in Model.init
    // but the typings of Model.init do not know this. Add the following to mute the typing error:
    createdAt: DataTypes.DATE,
    updatedAt: DataTypes.DATE,
  }, { sequelize });
  ```

### Usage without strict types for attributes

The typings for Sequelize v5 allowed you to define models without specifying types for the attributes.
This is still possible for backwards compatibility and for cases where you feel strict typing for attributes isn't worth it.

import modelInitNoAttributesExample from '!!raw-loader!@site/.sequelize/v7/test/types/typescript-docs/model-init-no-attributes.ts';

<CodeBlock className="language-typescript">
  {modelInitNoAttributesExample}
</CodeBlock>

### Usage of `Sequelize#define`

In Sequelize versions before v5, the default way of defining a model involved using [`Sequelize#define`](pathname:///api/v7/classes/Sequelize.html#define).
It's still possible to define models with that, and you can also add typings to these models using interfaces.

import defineExample from '!!raw-loader!@site/.sequelize/v7/test/types/typescript-docs/define.ts';

<CodeBlock className="language-typescript">
  {defineExample}
</CodeBlock>
